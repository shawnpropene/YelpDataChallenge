# This function will return a score of some given set of reivews 
# from the database. The score data is based on our word score
# from wordstar.py
# 
# This function will fetch the data from the database
# and then add the parsed result back to the database in the
# table features.
#
# Notice: guest database account will not have right to modify the database.

import scoresentence
import nltk
from nltk.stem.lancaster import LancasterStemmer
import pprint

SIZE = 100                           # the size of the set fetching from database. 
OFFSET = 0                            # the offset of the set 
OUTTOFILE = True                      # print the result to the file.
END = "top" + str(SIZE + OFFSET)      # related to the name of the file.

# Use the word data generated by wordstar.py to score a given sentence.
def scoreSentence(cursor, st, avg_score, std_dev):
    cursor.execute("SELECT content, user_id, business_id from yelp_review_flat limit " + str(SIZE) + ";")
    records = cursor.fetchall() 

    # Returned fields
    score = []
    weighted_score = []
    maximum = []
    minimum = []    
    word_len = []
    user_id = []
    business_id = []

    num = 1; # use for count the number of reviews already parsed.
    for record in records:
        print "Parsing the result " + str(num) + " in " + str(SIZE) + " results."
        user_id.append(record[1])
        business_id.append(record[2])
        ret = scoresentence.processline(cursor, record[0], st, avg_score, std_dev)
        if (ret[0] > 0):                  #If count > 0
            score.append(ret[1] / ret[0]) #score_sum / count
            maximum.append(ret[2])        #score_max
            minimum.append(ret[3])        #score_min
            weighted_score.append(ret[4]) #weighted_sum
        else:
            score.append(avg_score)
            weighted_score.append(avg_score)
            maximum.append(0.0)
            minimum.append(5.0)
        word_len.append(ret[0])
        num = num + 1
    return (records, score, maximum, minimum, weighted_score, word_len, user_id, business_id)

# Print out all the related score in the following form:
#     user_id, business_id, word_length, weighted_score, maximum_score, minimum_score, average_score
# Details about how to define each field can be found in scoresentence.py
def printscore(score, outtofile, end):
    if (outtofile):
        out = open("scoredistribution" + end + ".txt", "w")
    total = 0
    minimum = 5.0
    maximum = 0.0
    for x in range(0, len(score[4])):
        maximum = score[2][x]
        minimum = score[3][x]
        avg = score[1][x]
        weighted_score = score[4][x]
        word_len = score[5][x]
        uid = score[6][x]
        bid = score[7][x]
        if (OUTTOFILE):
            print >>out, str(uid) + ", " + str(bid) + ", " + str(word_len) + ", " + str(weighted_score) + ", " + str(maximum) + ", " + str(minimum) + ", " + str(avg) 
        else:
            print str(word_len) + ", " + str(weighted_score)
        total = total + weighted_score
        if weighted_score > maximum:
            maximum = weighted_score
        if weighted_score < minimum:
            minimum = weighted_score
    print "Average score is: " + str(total / len(score[4])) + "\nMaximum score is: " + str(maximum) + "\nMinimum score is: " + str(minimum)

if __name__ == "__main__":
    connect = scoresentence.dbConnect()
    cursor = connect[0]
    conn = connect[1]
    st = LancasterStemmer()
    cursor.execute("SELECT avg(star_sum/number), avg((star_sum / number) * (star_sum / number)) from word_star;")
    stat_data = cursor.fetchall()
    avg_score = stat_data[0][0]
    avg_score_square = stat_data[0][1]
    std_dev = (float(avg_score_square) - (float(avg_score) ** (2))) ** (1/2.0) 
    score = scoreSentence(cursor, st, avg_score, std_dev)
    printscore(score, OUTTOFILE, END)
    cursor.close()
    conn.close()
